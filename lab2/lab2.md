### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习0：填写已有实验6

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

答：这里的first-fit就是在整个链表中找第一个能够满足条件的内存块，然后将其分配给调用它的用户。

default_init函数：其实就是创建一个空链表，并将内部存储的页数置为零，表示内部还没有任何的页。

default_init_memmap函数：这个函数其实实现的是对于一些内存页交由物理内存管理器来管理，这里的base是一个页指针，所以这里首先将这个页数组的所有页表示为保留的，然后更新引用为0，因为这里的内存管理不一定是一个空的链表，所以这里将其按照内存地址进行排序，将这个base插入物理内存管理器中。

default_alloc_pages函数：这个函数实现了分配内存页的方法，首先找到这里的第一个比需要内存页数大的内存块，然后就是将其返回前的操作了，由于这里没有必要全部分配出去，所以当过大时，会分配需要的前n页，将剩下的再去串回pmm中，然后修改可用内存等。

default_free_pages函数：这个函数实现的是对于内存块的回收，回收时首先清空信息，并保证这里处在分配状态，然后将首页设置大小，再将其串回pmm中，但这里实现了对于连续内存地址的合并操作，将链表内连续的内存空间转换成一个较大的块，从而减少内存碎片。

这种分配方法还是存在较多问题的，如很可能会将一块很大的内存切分成很多小内存块，然后当需要大内存时，将会无法分配；且很容易产生很多内存碎片。

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

答：这里的Best-Fit算法其实和First-Fit算法原理上相差不大，不过Best-Fit算法会遍历整个链表，然后找到和这里需求的内存最相近的一个块，然后从中分配出需要的内存，这样可以较好的保存较大的内存块，从而保证需求尽可能被满足。

这里由于best_fit_init和best_fit_init_memmap、best_fit_free_pages的实现和first_fit完全相同，这里不再赘述了，主要在于对页的分配策略，这里在实现时对于整个链表进行遍历，同时源码中给出了min_size定义为整个链表总页数+1,这样便于我们处理这里的更新最小页，当这里遍历到的页满足大于n并且小于当前的最小页min_size时，就会更新我们的page和min_size，那么等到整个链表遍历完成后，就可以得到最后最合适的内存块，这里的时间复杂度为O(n)。

这里的best_fit算法还是存在内存碎片的问题，当分配合适内存后，剩下的块有更大可能会很小，导致出现很多的内存碎片。而且一般情况下这种分配最后的基本很难直接合并。

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。